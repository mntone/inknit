/*
 * inknit <https://github.com/mntone/inknit>
 *
 * Copyright (C) 2025 mntone <901816+mntone@users.noreply.github.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifdef __INTELLISENSE__
#include "../base.h.in"
#include "../shared/draw_line.h"
#else
#include "../base.h"
#include "shared/draw_line.h"
#endif

#define abs(val) ((val) < 0 ? -(val) : (val))

#ifdef INKNIT_ENABLE_BENCHMARKS
INKNIT_BMPREFIX
void _inknit_draw_line_2loop32(
	uint32_t      *data,
	uint32_t       stride,
	int32_t        x,
	int32_t        y,
	int32_t        x2,
	int32_t        y2,
	inknit_color_t color
) {
	int32_t dx = x2 - x;
	int32_t dy = y2 - y;

	const int32_t sx = dx > 0 ? 1 : dx < 0 ? -1 : 0;
	const int32_t sy = dy > 0 ? 1 : dy < 0 ? -1 : 0;

	dx = abs(dx);
	dy = abs(dy);

	if (dx > dy) {
		int32_t err = dx >> 1;
		while (1) {
			_inknit_draw_point32(data, stride, (uint32_t)x, (uint32_t)y, color);

			if (x == x2) {
				break;
			}

			x += sx;
			err -= dy;
			if (err <= 0) {
				y += sy;
				err += dx;
			}
		}
	} else {
		int32_t err = dy >> 1;
		while (1) {
			_inknit_draw_point32(data, stride, (uint32_t)x, (uint32_t)y, color);

			if (y == y2) {
				break;
			}

			y += sy;
			err -= dx;
			if (err <= 0) {
				x += sx;
				err += dy;
			}
		}
	}
}
#endif

INKNIT_BMPREFIX
void _inknit_draw_line_1loop32(
	uint32_t      *data,
	uint32_t       stride,
	int32_t        x1,
	int32_t        y,
	int32_t        x2,
	int32_t        y2,
	inknit_color_t color
) {
	int32_t dx = x2 - x1;
	int32_t dy = y2 - y;

	bool steep = abs(dx) < abs(dy);
	if (steep) {
		_inknit_swap_int32(&x1, &y);
		_inknit_swap_int32(&x2, &y2);
		_inknit_swap_int32(&dx, &dy);
	}
	if (x1 > x2) {
		_inknit_swap_int32(&x1, &x2);
		_inknit_swap_int32(&y, &y2);
		dx = -dx;
	}
	dy = abs(dy);

	int32_t err  = dx >> 1;
	int32_t step = y < y2 ? 1 : -1;
	for (int32_t x = x1; x <= x2; ++x) {
		if (steep) {
			_inknit_draw_point32(data, stride, (uint32_t)y, (uint32_t)x, color);
		} else {
			_inknit_draw_point32(data, stride, (uint32_t)x, (uint32_t)y, color);
		}

		err -= dy;
		if (err <= 0) {
			y += step;
			err += dx;
		}
	}
}

void _inknit_draw_line32(
	uint32_t      *data,
	uint32_t       stride,
	int32_t        x1,
	int32_t        y1,
	int32_t        x2,
	int32_t        y2,
	inknit_color_t color
) {
	_inknit_draw_line_1loop32(data, stride, x1, y1, x2, y2, color);
}

void _inknit_draw_line_with_clip32(
	uint32_t *INKNIT_RESTRICT                 data,
	uint32_t                                  stride,
	int32_t                                   x1,
	int32_t                                   y1,
	int32_t                                   x2,
	int32_t                                   y2,
	inknit_color_t                            color,
	const struct inknit_rect *INKNIT_RESTRICT clip_rect
) {
	INKNIT_ASSUME_COORD_X(x1);
	INKNIT_ASSUME_COORD_X(x2);
	INKNIT_ASSUME_COORD_Y(y1);
	INKNIT_ASSUME_COORD_Y(y2);
	INKNIT_ASSUME_COLOR(color);
	INKNIT_ASSUME_CLIP_RECT(clip_rect);

	if (INKNIT_UNLIKELY(x1 == x2)) {
		if (y1 > y2) {
			_inknit_swap_int32(&y1, &y2);
		}
		_inknit_draw_vline_with_clip32(data, stride, x1, y1, y2, color, clip_rect);
		return;
	}

	if (INKNIT_UNLIKELY(y1 == y2)) {
		if (x1 > x2) {
			_inknit_swap_int32(&x1, &x2);
		}
		_inknit_draw_hline_with_clip32(data, stride, x1, x2, y1, color, clip_rect);
		return;
	}

	if (_inknit_clip_line_to_bounds(&x1, &y1, &x2, &y2, clip_rect)) {
		_inknit_draw_line32(data, stride, x1, y1, x2, y2, color);
	}
}

void PUBLIC_FUNCNAME(draw_line)(
	struct inknit_image *image, int32_t x1, int32_t y1, int32_t x2, int32_t y2, inknit_color_t color
) {
	INKNIT_ASSUME_IMAGE(image);

	const uint32_t stride = bytes_to_pixels(image->stride);

	struct inknit_rect clip_rect = {
		0,
		0,
		image->width - 1,
		(int16_t)(image->height - 1),
	};
	_inknit_draw_line_with_clip32(image->data, stride, x1, y1, x2, y2, color, &clip_rect);
}
